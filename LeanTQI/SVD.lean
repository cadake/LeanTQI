import Mathlib

namespace LinearMap

variable {E F ùïÇ : Type*} [RCLike ùïÇ]
variable [NormedAddCommGroup E] [InnerProductSpace ùïÇ E]
  [NormedAddCommGroup F] [InnerProductSpace ùïÇ F]
  [FiniteDimensional ùïÇ E] [FiniteDimensional ùïÇ F]

variable (T : E ‚Üí‚Çó[ùïÇ] F)
variable {n m : ‚Ñï} (hn : Module.finrank ùïÇ E = n) (hm : Module.finrank ùïÇ F = m)

open LinearMap
#check Matrix.IsHermitian.rank_eq_card_non_zero_eigs
#check LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply
@[simp]
noncomputable def AdjMulSelf : E ‚Üí‚Çó[ùïÇ] E := (adjoint T) ‚àò‚Çó T

@[simp]
noncomputable def SelfMulAdj : F ‚Üí‚Çó[ùïÇ] F := T ‚àò‚Çó (adjoint T)

theorem adj_mul_self_isSelfAdj : IsSelfAdjoint T.AdjMulSelf := by
  simp only [IsSelfAdjoint, star, AdjMulSelf, adjoint_comp, adjoint_adjoint]

theorem self_mul_adj_isSelfAdj : IsSelfAdjoint T.SelfMulAdj := by
  simp only [IsSelfAdjoint, star, SelfMulAdj, adjoint_comp, adjoint_adjoint]

theorem adj_mul_self_isSymm : IsSymmetric T.AdjMulSelf := by
  simp only [AdjMulSelf]
  exact (isSymmetric_iff_isSelfAdjoint T.AdjMulSelf).2 (adj_mul_self_isSelfAdj T)

theorem self_mul_adj_isSymm : IsSymmetric T.SelfMulAdj := by
  simp only [SelfMulAdj]
  exact (isSymmetric_iff_isSelfAdjoint T.SelfMulAdj).2 (self_mul_adj_isSelfAdj T)

@[simp]
noncomputable def sSingularValues' : Fin n ‚Üí ‚Ñù :=
  fun i => ‚àö((IsSymmetric.eigenvalues (adj_mul_self_isSymm T) hn) i)

-- def FinReverse : Fin n ‚Üí Fin n := fun i =>
--   if n = 0 then (Fin.mk 0 (show 0 < n by exact Fin.pos i))
--   else (Fin.mk (n - 1 - i) (Nat.sub_one_sub_lt i.isLt))

-- theorem antitone_finreverse : Antitone (FinReverse (n:=n)) := by
--   dsimp [Antitone, FinReverse]
--   intro a b hab
--   by_cases hn : n = 0
--   ¬∑ simp only [if_pos hn, le_refl]
--   simp only [if_neg hn, @sub_le_sub_iff_left, Fin.mk_le_mk, Nat.sub_sub]
--   exact Nat.sub_le_sub_left (Nat.add_le_add_left hab 1) n

-- @[simp]
-- noncomputable def sSingularValues : Fin n ‚Üí ‚Ñù :=
--   ((sSingularValues' T hn) ‚àò (Tuple.sort (sSingularValues' T hn))) ‚àò (FinReverse (n:=n))

noncomputable def DecPerm : (Fin n) ‚âÉ (Fin n) where
  toFun := (Tuple.sort (sSingularValues' T hn)) ‚àò (Fin.revPerm)
  invFun := (Fin.revPerm) ‚àò (Tuple.sort (sSingularValues' T hn)).invFun
  left_inv := by
    simp only [Function.LeftInverse, Equiv.invFun_as_coe, Function.comp_apply, Fin.revPerm_apply,
      Equiv.symm_apply_apply, Fin.rev_rev, implies_true]
  right_inv := by
    simp only [Function.RightInverse, Function.LeftInverse]
    intro i
    simp only [Equiv.invFun_as_coe, Function.comp_apply, Fin.revPerm_apply, Fin.rev_rev,
      Equiv.apply_symm_apply]

@[simp]
noncomputable def sSingularValues : Fin n ‚Üí ‚Ñù :=
  (sSingularValues' T hn) ‚àò ((Tuple.sort (sSingularValues' T hn)) ‚àò (Fin.revPerm))

local notation "svdœÉ" T => sSingularValues T hn

@[simp]
noncomputable def mSingularValues' : Fin m ‚Üí ‚Ñù :=
  fun i => ‚àö((IsSymmetric.eigenvalues (self_mul_adj_isSymm T) hm) i)

@[simp]
noncomputable def mSingularValues : Fin m ‚Üí ‚Ñù :=
  (mSingularValues' T hm) ‚àò ((Tuple.sort (mSingularValues' T hm)) ‚àò (Fin.revPerm))

theorem singular_values_nonneg (i : Fin n) : 0 ‚â§ (svdœÉ T) i := by
  simp only [sSingularValues, Function.comp_apply, Fin.revPerm_apply, sSingularValues', AdjMulSelf,
    Real.sqrt_nonneg]

theorem antitone_singular_values : Antitone (svdœÉ T) := by
  rw [sSingularValues, ‚Üê Function.comp_assoc]
  apply Monotone.comp_antitone
  apply Tuple.monotone_sort
  intro a b hab
  simp only [Fin.revPerm_apply, Fin.rev_le_rev]
  assumption

-- todo: rank of (adjoint A) * A equals rank of A
example : Cardinal.toNat T.AdjMulSelf.rank = Cardinal.toNat T.rank := by
  sorry

example (T : E ‚Üí‚Çó[ùïÇ] E) : Cardinal.toNat T.rank = Fintype.card {i // (Module.End.Eigenvalues.val T) i ‚â† 0} := by
  sorry

theorem rank_eq_card_nonzero_sigs : Cardinal.toNat T.rank =
    Fintype.card {i // (svdœÉ T) i ‚â† 0} := by
  sorry

theorem sigs_pos_before_rank (i : Fin n) (hi : i < Cardinal.toNat T.rank) : 0 < (svdœÉ T) i := by
  by_contra! g
  have hœÉi : (svdœÉ T) i = 0 := le_antisymm g (singular_values_nonneg T hn i)
  have hij' : ‚àÄ j, i ‚â§ j ‚Üí (svdœÉ T) j = 0 := by
    intro j hij
    have : (svdœÉ T) i ‚â• (svdœÉ T) j := antitone_singular_values T hn hij
    rw [hœÉi] at this
    exact le_antisymm this (singular_values_nonneg T hn j)
  have h‚ÇÅ : Fintype.card {i // (svdœÉ T) i = 0} = Fintype.card (Fin n) - Fintype.card {i // (svdœÉ T) i ‚â† 0} := by
      simp_rw [‚Üê @Fintype.card_subtype_compl, ne_eq, Decidable.not_not]
  have h‚ÇÇ : Fintype.card { j // i ‚â§ j } ‚â§ Fintype.card { j // (svdœÉ T) j = 0} := by
      exact Fintype.card_subtype_mono (LE.le i) (fun x ‚Ü¶ (svdœÉ T) x = 0) hij'
  rw [h‚ÇÅ, ‚Üê rank_eq_card_nonzero_sigs] at h‚ÇÇ
  have h‚ÇÉ : Fintype.card { j // i ‚â§ j } > Fintype.card (Fin n) - Cardinal.toNat T.rank := by
    have : Fintype.card { j // i ‚â§ j } = Fintype.card (Fin n) - i := by
      have : Fintype.card { j // j < i } = i := Fintype.card_fin_lt_of_le Fin.is_le'
      simp_rw [‚Üê this, ‚Üê @Fintype.card_subtype_compl, not_lt]
    rw [this, Fintype.card_fin]
    exact Nat.sub_lt_sub_left (i.isLt) hi
  have h‚ÇÑ : Fintype.card (Fin n) - Cardinal.toNat T.rank < Fintype.card (Fin n) - Cardinal.toNat T.rank := by
    exact Nat.lt_of_lt_of_le h‚ÇÉ h‚ÇÇ
  rw [lt_self_iff_false] at h‚ÇÑ
  exact h‚ÇÑ

theorem sigs_zero_after_rank (i : Fin n) (hi : i ‚â• Cardinal.toNat T.rank) : (svdœÉ T) i = 0 := by
  by_contra! g
  have hœÉi : (svdœÉ T) i > 0 :=
    lt_of_le_of_ne ((singular_values_nonneg T hn i)) (_root_.id (Ne.symm g))
  have hij' : ‚àÄ j, j ‚â§ i ‚Üí (svdœÉ T) j > 0 :=
    fun j hij => gt_of_ge_of_gt (antitone_singular_values T hn hij) hœÉi
  have hij'' : ‚àÄ j, j ‚â§ i ‚Üí (svdœÉ T) j ‚â† 0 := by
    intro j hj
    exact Ne.symm (ne_of_lt (hij' j hj))
  have h‚ÇÅ : Fintype.card {i // (svdœÉ T) i ‚â† 0} = Fintype.card (Fin n) - Fintype.card {i // (svdœÉ T) i = 0} := by
    simp_rw [‚Üê @Fintype.card_subtype_compl]
  have h‚ÇÇ : Fintype.card { j // j ‚â§ i } ‚â§ Fintype.card { j // (svdœÉ T) j ‚â† 0} := by
    exact Fintype.card_subtype_mono (fun x ‚Ü¶ x ‚â§ i) (fun x ‚Ü¶ (svdœÉ T) x ‚â† 0) hij''
  rw [h‚ÇÅ] at h‚ÇÇ
  have h‚ÇÉ : Fintype.card { j // j ‚â§ i } > Cardinal.toNat T.rank := by
    have : Fintype.card { j // j ‚â§ i } = i + 1 := by
      have : Fintype.card { j // j < i } = i := Fintype.card_fin_lt_of_le Fin.is_le'
      have : Fintype.card { j // j ‚â§ i } = Fintype.card { j // j < (Fin.mk (n:=n) (i.val + 1) (by sorry))} := by
        sorry
      simp_rw [this]
      apply Fintype.card_fin_lt_of_le Fin.is_le'
    rw [this]
    exact Order.lt_add_one_iff.mpr hi
  have h‚ÇÑ : Cardinal.toNat T.rank < Fintype.card (Fin n) - Fintype.card { i // (svdœÉ T) i = 0 } := by
    exact Nat.lt_of_lt_of_le h‚ÇÉ h‚ÇÇ
  rw [‚Üê h‚ÇÅ, rank_eq_card_nonzero_sigs T hn, lt_self_iff_false] at h‚ÇÑ
  exact h‚ÇÑ


#check Orthonormal
#check LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis
#check LinearMap.IsSymmetric.apply_eigenvectorBasis

@[simp]
noncomputable def RightSingularVectors' : OrthonormalBasis (Fin n) ùïÇ E :=
  LinearMap.IsSymmetric.eigenvectorBasis (T := T.AdjMulSelf) (adj_mul_self_isSymm T) hn

@[simp]
noncomputable def RightSingularVectors : (Fin n) ‚Üí E :=
  (RightSingularVectors' T hn).toBasis ‚àò ((Tuple.sort (sSingularValues' T hn)) ‚àò (Fin.revPerm))

local notation "svdV" T => RightSingularVectors T hn

theorem adjmulself_eigenvalues_nonneg (i : Fin n) : 0 ‚â§ (adj_mul_self_isSymm T).eigenvalues hn i := by
  let Œº := (adj_mul_self_isSymm T).eigenvalues hn i
  have hŒº : Module.End.HasEigenvalue T.AdjMulSelf Œº := by
    exact IsSymmetric.hasEigenvalue_eigenvalues (adj_mul_self_isSymm T) hn i
  apply eigenvalue_nonneg_of_nonneg hŒº
  intro v
  rw [AdjMulSelf, coe_comp, Function.comp_apply, @adjoint_inner_right, @inner_self_eq_norm_mul_norm]
  exact mul_nonneg (norm_nonneg (T v)) (norm_nonneg (T v))

theorem adjmulself_eigvec_eq_sig_square_smul_eigvec (i : Fin n) : (T.AdjMulSelf) ((svdV T) i) =
    ((svdœÉ T) i ^ 2 : ùïÇ) ‚Ä¢ (svdV T) i := by
  simp only [AdjMulSelf, RightSingularVectors, RightSingularVectors', OrthonormalBasis.coe_toBasis,
    Function.comp_apply, Fin.revPerm_apply, IsSymmetric.apply_eigenvectorBasis, sSingularValues,
    sSingularValues', map_pow]
  norm_cast
  have : ((1 / 2) * (2 : ‚Ñù) = 1) := by linarith
  rw [Real.sqrt_eq_rpow, ‚Üê Real.rpow_two, ‚Üê Real.rpow_mul, this, Real.rpow_one]
  exact adjmulself_eigenvalues_nonneg T hn ((Tuple.sort (T.sSingularValues' hn)) i.rev)

#check Matrix.PosSemidef.eigenvalues_nonneg
#check Matrix.IsHermitian.rank_eq_card_non_zero_eigs
#check toMatrix

theorem orthonormal_right_singular_vectors : Orthonormal ùïÇ (svdV T) := by
  rw [RightSingularVectors]
  refine Orthonormal.comp ?_ (‚áë(Tuple.sort (T.sSingularValues' hn)) ‚àò ‚áëFin.revPerm) ?_
  apply OrthonormalBasis.orthonormal
  simp only [Function.Injective, Function.comp_apply, Fin.revPerm_apply,
    EmbeddingLike.apply_eq_iff_eq, Fin.rev_inj, imp_self, implies_true]

-- todo: rank of a linearmap equals nums of nonzero eigenvalues
example (T : E ‚Üí‚Çó[ùïÇ] E) (hT : T.IsSymmetric) : Cardinal.toNat T.rank =
    (Matrix.diagonal (hT.eigenvalues hn)).rank := by
  dsimp [rank]
  rw [‚Üê Submodule.finrank_eq_rank]
  sorry

-- todo: rank of a linearmap equals nums of nonzero singularvalues
example : Cardinal.toNat T.rank = (Matrix.diagonal (svdœÉ T)).rank := by
  simp only [sSingularValues]
  sorry


noncomputable def LeftSingularVectors' : OrthonormalBasis (Fin m) ùïÇ F :=
  LinearMap.IsSymmetric.eigenvectorBasis (T := T.SelfMulAdj) (self_mul_adj_isSymm T) hm

noncomputable def LeftSingularVectors : (Fin m) ‚Üí F :=
  (LeftSingularVectors' T hm).toBasis ‚àò ((Tuple.sort (mSingularValues' T hm)) ‚àò (Fin.revPerm))

local notation "svdU" T => LeftSingularVectors T hm

theorem orthonormal_left_singular_vectors : Orthonormal ùïÇ (svdU T) := by
  rw [LeftSingularVectors]
  refine Orthonormal.comp ?_ (‚áë(Tuple.sort (T.mSingularValues' hm)) ‚àò ‚áëFin.revPerm) ?_
  apply OrthonormalBasis.orthonormal
  simp only [Function.Injective, Function.comp_apply, Fin.revPerm_apply,
    EmbeddingLike.apply_eq_iff_eq, Fin.rev_inj, imp_self, implies_true]

open scoped InnerProductSpace


#check svdœÉ T
#check hn

#check Isometry
theorem singular_value_decomposition (T : E ‚Üí‚Çó[ùïÇ] F) :
    ‚àÉ (r : ‚Ñï) (œÉ : Fin r ‚Üí ‚Ñù) (hœÉ : Antitone œÉ) (hœÉ' : ‚àÄ i, 0 ‚â§ œÉ i) (V : Fin r ‚Üí E) (W : Fin r ‚Üí F)
    (hv : Orthonormal ùïÇ V) (hw : Orthonormal ùïÇ W),
    ‚àÄ (v : E), T v = ‚àë (i : Fin r), ((œÉ i) * ‚ü™v,  (V i)‚ü´_ùïÇ) ‚Ä¢ (W i) := by
  let re := Cardinal.toNat (Module.rank ùïÇ E)
  let rf := Cardinal.toNat (Module.rank ùïÇ F)
  have hre : Module.finrank ùïÇ E = re := rfl
  have hrf : Module.finrank ùïÇ F = rf := rfl
  let œÉ := (sSingularValues T (n:=re) hre)
  let r := Cardinal.toNat T.rank
  -- let œÉ' := fun (i : Fin (min r r')) => œÉ i
  -- have hœÉ : Antitone œÉ := antitone_singular_values T hr
  -- have hœÉ' : ‚àÄ i, 0 ‚â§ œÉ i := fun i ‚Ü¶ singular_values_nonneg T hr i
  -- let V := (RightSingularVectors T hr)
  -- let W := (LeftSingularVectors T hr')
  -- use Nat.min r r'
  sorry

end LinearMap
